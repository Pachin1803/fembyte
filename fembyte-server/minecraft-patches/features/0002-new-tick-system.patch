From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: dractical <dracticalrblx@gmail.com>
Date: Wed, 19 Nov 2025 10:48:04 -0500
Subject: [PATCH] new tick system


diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index dda8d38ef61672cc714d9e5a475f9b0412ed5ff9..413ac840edc17d1e365212d47f4d67ab2210e50f 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -33,6 +33,7 @@ import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+import com.dractical.fembyte.perf.DensityTickSystem;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportType;
@@ -862,54 +863,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     // Paper start - optimise random ticking
     private final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed());
+    // fembyte start - tick system
+    private final DensityTickSystem densityTickSystem = new DensityTickSystem(this, this.simpleRandom);
 
     private void optimiseRandomTick(final LevelChunk chunk, final int tickSpeed) {
-        final LevelChunkSection[] sections = chunk.getSections();
-        final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection((ServerLevel)(Object)this);
-        final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom simpleRandom = this.simpleRandom;
-        final boolean doubleTickFluids = !ca.spottedleaf.moonrise.common.PlatformHooks.get().configFixMC224294();
-
-        final ChunkPos cpos = chunk.getPos();
-        final int offsetX = cpos.x << 4;
-        final int offsetZ = cpos.z << 4;
-
-        for (int sectionIndex = 0, sectionsLen = sections.length; sectionIndex < sectionsLen; sectionIndex++) {
-            final int offsetY = (sectionIndex + minSection) << 4;
-            final LevelChunkSection section = sections[sectionIndex];
-            final net.minecraft.world.level.chunk.PalettedContainer<net.minecraft.world.level.block.state.BlockState> states = section.states;
-            if (!section.isRandomlyTickingBlocks()) {
-                continue;
-            }
-
-            final ca.spottedleaf.moonrise.common.list.ShortList tickList = ((ca.spottedleaf.moonrise.patches.block_counting.BlockCountingChunkSection)section).moonrise$getTickingBlockList();
-
-            for (int i = 0; i < tickSpeed; ++i) {
-                final int tickingBlocks = tickList.size();
-                final int index = simpleRandom.nextInt() & ((16 * 16 * 16) - 1);
-
-                if (index >= tickingBlocks) {
-                    // most of the time we fall here
-                    continue;
-                }
-
-                final int location = (int)tickList.getRaw(index) & 0xFFFF;
-                final BlockState state = states.get(location);
-
-                // do not use a mutable pos, as some random tick implementations store the input without calling immutable()!
-                final BlockPos pos = new BlockPos((location & 15) | offsetX, ((location >>> (4 + 4)) & 15) | offsetY, ((location >>> 4) & 15) | offsetZ);
-
-                state.randomTick((ServerLevel)(Object)this, pos, simpleRandom);
-                if (doubleTickFluids) {
-                    final FluidState fluidState = state.getFluidState();
-                    if (fluidState.isRandomlyTicking()) {
-                        fluidState.randomTick((ServerLevel)(Object)this, pos, simpleRandom);
-                    }
-                }
-            }
-        }
-
-        return;
+        this.densityTickSystem.tick(chunk, tickSpeed);
     }
+    // fembyte end - tick system
     // Paper end - optimise random ticking
 
     public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
